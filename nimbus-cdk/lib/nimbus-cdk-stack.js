"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApiGatewayStack = void 0;
const cdk = require("aws-cdk-lib");
const lambda = require("aws-cdk-lib/aws-lambda");
const apigateway = require("aws-cdk-lib/aws-apigateway");
const fs = require("fs");
const path = require("path");
const aws_ecr_assets_1 = require("aws-cdk-lib/aws-ecr-assets");
class ApiGatewayStack extends cdk.Stack {
    constructor(scope, id, props) {
        super(scope, id, props);
        const finishedDirPath = this.node.tryGetContext("finishedDirPath");
        if (!finishedDirPath || typeof finishedDirPath !== "string") {
            throw new Error('CDK context variable "finishedDirPath" is required and must be a string.');
        }
        if (!fs.existsSync(finishedDirPath)) {
            console.warn(`Warning: Provided finishedDirPath does not exist: ${finishedDirPath}`);
        }
        const api = new apigateway.RestApi(this, "PredictRestApi", {
            restApiName: "PredictRestApi",
            deployOptions: {
                stageName: "prod",
            },
        });
        const modelsPath = JSON.parse(fs.readFileSync(path.resolve(__dirname, '../../nimbus-cli/nimbus-config.json'), 'utf8'));
        const modelsJSON = fs.readFileSync(path.resolve(modelsPath.localStorage, 'finished_dir/models.json'), 'utf8');
        const parsedModels = { models: [] };
        JSON.parse(modelsJSON).forEach((obj) => {
            parsedModels.models.push(obj.modelName);
        });
        const defaultLambda = new lambda.Function(this, "DefaultLambda", {
            runtime: lambda.Runtime.NODEJS_20_X,
            handler: "index.handler",
            code: lambda.Code.fromInline(`exports.handler = async () => {
          return {
            statusCode: 200,
            headers: { 'Content-Type': 'application/json' },
            body: '${JSON.stringify(parsedModels)}'
          };
        };`),
        });
        api.root.addMethod("GET", new apigateway.LambdaIntegration(defaultLambda));
        const modelsConfigPath = path.join(finishedDirPath, "models.json");
        let models = [];
        if (fs.existsSync(modelsConfigPath)) {
            try {
                models = JSON.parse(fs.readFileSync(modelsConfigPath, "utf8"));
            }
            catch (error) {
                console.error(`Error reading or parsing models.json from ${modelsConfigPath}:`, error);
            }
        }
        models.forEach((model) => {
            const modelDirPath = path.join(finishedDirPath, model.modelName);
            if (!fs.existsSync(modelDirPath)) {
                console.warn(`Warning: Model directory does not exist, skipping deployment for ${model.modelName}: ${modelDirPath}`);
                return;
            }
            const modelLambda = new lambda.DockerImageFunction(this, `Lambda_${model.modelName}`, {
                code: lambda.DockerImageCode.fromImageAsset(modelDirPath, {
                    platform: aws_ecr_assets_1.Platform.LINUX_AMD64,
                }),
                memorySize: 3008,
                timeout: cdk.Duration.seconds(60),
            });
            const modelResource = api.root.addResource(model.modelName);
            const predictResource = modelResource.addResource("predict");
            predictResource.addCorsPreflight({
                allowOrigins: apigateway.Cors.ALL_ORIGINS,
                allowMethods: ["POST", "OPTIONS"],
                allowHeaders: ["Content-Type"],
            });
            predictResource.addMethod("POST", new apigateway.LambdaIntegration(modelLambda));
            new cdk.CfnOutput(this, `ModelEndpoint_${model.modelName}`, {
                value: `${api.url}${model.modelName}/predict`,
            });
        });
        new cdk.CfnOutput(this, "RestApiUrl", {
            value: api.url,
        });
    }
}
exports.ApiGatewayStack = ApiGatewayStack;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmltYnVzLWNkay1zdGFjay5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIm5pbWJ1cy1jZGstc3RhY2sudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsbUNBQW1DO0FBQ25DLGlEQUFpRDtBQUNqRCx5REFBeUQ7QUFFekQseUJBQXlCO0FBQ3pCLDZCQUE2QjtBQUM3QiwrREFBc0Q7QUFTdEQsTUFBYSxlQUFnQixTQUFRLEdBQUcsQ0FBQyxLQUFLO0lBQzVDLFlBQVksS0FBZ0IsRUFBRSxFQUFVLEVBQUUsS0FBc0I7UUFDOUQsS0FBSyxDQUFDLEtBQUssRUFBRSxFQUFFLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFFeEIsTUFBTSxlQUFlLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsaUJBQWlCLENBQUMsQ0FBQztRQUVuRSxJQUFJLENBQUMsZUFBZSxJQUFJLE9BQU8sZUFBZSxLQUFLLFFBQVEsRUFBRSxDQUFDO1lBQzVELE1BQU0sSUFBSSxLQUFLLENBQ2IsMEVBQTBFLENBQzNFLENBQUM7UUFDSixDQUFDO1FBRUQsSUFBSSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsZUFBZSxDQUFDLEVBQUUsQ0FBQztZQUNwQyxPQUFPLENBQUMsSUFBSSxDQUNWLHFEQUFxRCxlQUFlLEVBQUUsQ0FDdkUsQ0FBQztRQUNKLENBQUM7UUFFRCxNQUFNLEdBQUcsR0FBRyxJQUFJLFVBQVUsQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFLGdCQUFnQixFQUFFO1lBQ3pELFdBQVcsRUFBRSxnQkFBZ0I7WUFDN0IsYUFBYSxFQUFFO2dCQUNiLFNBQVMsRUFBRSxNQUFNO2FBQ2xCO1NBQ0YsQ0FBQyxDQUFDO1FBRUgsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsU0FBUyxFQUFFLHFDQUFxQyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQztRQUN2SCxNQUFNLFVBQVUsR0FBRyxFQUFFLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLFlBQVksRUFBRSwwQkFBMEIsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBUzlHLE1BQU0sWUFBWSxHQUE2QixFQUFFLE1BQU0sRUFBRSxFQUFFLEVBQUUsQ0FBQztRQUU3RCxJQUFJLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBa0IsQ0FBQyxPQUFPLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRTtZQUN2RCxZQUFZLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDMUMsQ0FBQyxDQUFDLENBQUM7UUFFSCxNQUFNLGFBQWEsR0FBRyxJQUFJLE1BQU0sQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLGVBQWUsRUFBRTtZQUMvRCxPQUFPLEVBQUUsTUFBTSxDQUFDLE9BQU8sQ0FBQyxXQUFXO1lBQ25DLE9BQU8sRUFBRSxlQUFlO1lBQ3hCLElBQUksRUFBRSxNQUFNLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FDMUI7Ozs7cUJBSWEsSUFBSSxDQUFDLFNBQVMsQ0FBQyxZQUFZLENBQUM7O1dBRXRDLENBQ0o7U0FDRixDQUFDLENBQUM7UUFDSCxHQUFHLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLEVBQUUsSUFBSSxVQUFVLENBQUMsaUJBQWlCLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQztRQUUzRSxNQUFNLGdCQUFnQixHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsZUFBZSxFQUFFLGFBQWEsQ0FBQyxDQUFDO1FBQ25FLElBQUksTUFBTSxHQUFrQixFQUFFLENBQUM7UUFFL0IsSUFBSSxFQUFFLENBQUMsVUFBVSxDQUFDLGdCQUFnQixDQUFDLEVBQUUsQ0FBQztZQUNwQyxJQUFJLENBQUM7Z0JBQ0gsTUFBTSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLFlBQVksQ0FBQyxnQkFBZ0IsRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDO1lBQ2pFLENBQUM7WUFBQyxPQUFPLEtBQUssRUFBRSxDQUFDO2dCQUNmLE9BQU8sQ0FBQyxLQUFLLENBQ1gsNkNBQTZDLGdCQUFnQixHQUFHLEVBQ2hFLEtBQUssQ0FDTixDQUFDO1lBQ0osQ0FBQztRQUNILENBQUM7UUFFRCxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUMsS0FBSyxFQUFFLEVBQUU7WUFDdkIsTUFBTSxZQUFZLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxlQUFlLEVBQUUsS0FBSyxDQUFDLFNBQVMsQ0FBQyxDQUFDO1lBRWpFLElBQUksQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLFlBQVksQ0FBQyxFQUFFLENBQUM7Z0JBQ2pDLE9BQU8sQ0FBQyxJQUFJLENBQ1Ysb0VBQW9FLEtBQUssQ0FBQyxTQUFTLEtBQUssWUFBWSxFQUFFLENBQ3ZHLENBQUM7Z0JBQ0YsT0FBTztZQUNULENBQUM7WUFFRCxNQUFNLFdBQVcsR0FBRyxJQUFJLE1BQU0sQ0FBQyxtQkFBbUIsQ0FDaEQsSUFBSSxFQUNKLFVBQVUsS0FBSyxDQUFDLFNBQVMsRUFBRSxFQUMzQjtnQkFDRSxJQUFJLEVBQUUsTUFBTSxDQUFDLGVBQWUsQ0FBQyxjQUFjLENBQUMsWUFBWSxFQUFFO29CQUN4RCxRQUFRLEVBQUUseUJBQVEsQ0FBQyxXQUFXO2lCQUMvQixDQUFDO2dCQUNGLFVBQVUsRUFBRSxJQUFJO2dCQUNoQixPQUFPLEVBQUUsR0FBRyxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDO2FBQ2xDLENBQ0YsQ0FBQztZQUVGLE1BQU0sYUFBYSxHQUFHLEdBQUcsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsQ0FBQztZQUM1RCxNQUFNLGVBQWUsR0FBRyxhQUFhLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQyxDQUFDO1lBQzdELGVBQWUsQ0FBQyxnQkFBZ0IsQ0FBQztnQkFDL0IsWUFBWSxFQUFFLFVBQVUsQ0FBQyxJQUFJLENBQUMsV0FBVztnQkFDekMsWUFBWSxFQUFFLENBQUMsTUFBTSxFQUFFLFNBQVMsQ0FBQztnQkFDakMsWUFBWSxFQUFFLENBQUMsY0FBYyxDQUFDO2FBQy9CLENBQUMsQ0FBQztZQUNILGVBQWUsQ0FBQyxTQUFTLENBQ3ZCLE1BQU0sRUFDTixJQUFJLFVBQVUsQ0FBQyxpQkFBaUIsQ0FBQyxXQUFXLENBQUMsQ0FDOUMsQ0FBQztZQUVGLElBQUksR0FBRyxDQUFDLFNBQVMsQ0FBQyxJQUFJLEVBQUUsaUJBQWlCLEtBQUssQ0FBQyxTQUFTLEVBQUUsRUFBRTtnQkFDMUQsS0FBSyxFQUFFLEdBQUcsR0FBRyxDQUFDLEdBQUcsR0FBRyxLQUFLLENBQUMsU0FBUyxVQUFVO2FBQzlDLENBQUMsQ0FBQztRQUNMLENBQUMsQ0FBQyxDQUFDO1FBRUgsSUFBSSxHQUFHLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRSxZQUFZLEVBQUU7WUFDcEMsS0FBSyxFQUFFLEdBQUcsQ0FBQyxHQUFHO1NBQ2YsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztDQUNGO0FBakhELDBDQWlIQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGNkayBmcm9tIFwiYXdzLWNkay1saWJcIjtcbmltcG9ydCAqIGFzIGxhbWJkYSBmcm9tIFwiYXdzLWNkay1saWIvYXdzLWxhbWJkYVwiO1xuaW1wb3J0ICogYXMgYXBpZ2F0ZXdheSBmcm9tIFwiYXdzLWNkay1saWIvYXdzLWFwaWdhdGV3YXlcIjtcbmltcG9ydCB7IENvbnN0cnVjdCB9IGZyb20gXCJjb25zdHJ1Y3RzXCI7XG5pbXBvcnQgKiBhcyBmcyBmcm9tIFwiZnNcIjtcbmltcG9ydCAqIGFzIHBhdGggZnJvbSBcInBhdGhcIjtcbmltcG9ydCB7IFBsYXRmb3JtIH0gZnJvbSBcImF3cy1jZGstbGliL2F3cy1lY3ItYXNzZXRzXCI7XG5cbmludGVyZmFjZSBNb2RlbENvbmZpZyB7XG4gIG1vZGVsTmFtZTogc3RyaW5nO1xuICBtb2RlbFR5cGU6IHN0cmluZztcbiAgbW9kZWxQYXRoT3JOYW1lOiBzdHJpbmc7XG4gIGRlc2NyaXB0aW9uPzogc3RyaW5nO1xufVxuXG5leHBvcnQgY2xhc3MgQXBpR2F0ZXdheVN0YWNrIGV4dGVuZHMgY2RrLlN0YWNrIHtcbiAgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM/OiBjZGsuU3RhY2tQcm9wcykge1xuICAgIHN1cGVyKHNjb3BlLCBpZCwgcHJvcHMpO1xuXG4gICAgY29uc3QgZmluaXNoZWREaXJQYXRoID0gdGhpcy5ub2RlLnRyeUdldENvbnRleHQoXCJmaW5pc2hlZERpclBhdGhcIik7XG5cbiAgICBpZiAoIWZpbmlzaGVkRGlyUGF0aCB8fCB0eXBlb2YgZmluaXNoZWREaXJQYXRoICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdDREsgY29udGV4dCB2YXJpYWJsZSBcImZpbmlzaGVkRGlyUGF0aFwiIGlzIHJlcXVpcmVkIGFuZCBtdXN0IGJlIGEgc3RyaW5nLicsXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICghZnMuZXhpc3RzU3luYyhmaW5pc2hlZERpclBhdGgpKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIGBXYXJuaW5nOiBQcm92aWRlZCBmaW5pc2hlZERpclBhdGggZG9lcyBub3QgZXhpc3Q6ICR7ZmluaXNoZWREaXJQYXRofWAsXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IGFwaSA9IG5ldyBhcGlnYXRld2F5LlJlc3RBcGkodGhpcywgXCJQcmVkaWN0UmVzdEFwaVwiLCB7XG4gICAgICByZXN0QXBpTmFtZTogXCJQcmVkaWN0UmVzdEFwaVwiLFxuICAgICAgZGVwbG95T3B0aW9uczoge1xuICAgICAgICBzdGFnZU5hbWU6IFwicHJvZFwiLFxuICAgICAgfSxcbiAgICB9KTtcbiAgICBcbiAgICBjb25zdCBtb2RlbHNQYXRoID0gSlNPTi5wYXJzZShmcy5yZWFkRmlsZVN5bmMocGF0aC5yZXNvbHZlKF9fZGlybmFtZSwgJy4uLy4uL25pbWJ1cy1jbGkvbmltYnVzLWNvbmZpZy5qc29uJyksICd1dGY4JykpO1xuICAgIGNvbnN0IG1vZGVsc0pTT04gPSBmcy5yZWFkRmlsZVN5bmMocGF0aC5yZXNvbHZlKG1vZGVsc1BhdGgubG9jYWxTdG9yYWdlLCAnZmluaXNoZWRfZGlyL21vZGVscy5qc29uJyksICd1dGY4Jyk7XG5cbiAgICBpbnRlcmZhY2UgTW9kZWxFbnRyeSB7XG4gICAgICBtb2RlbE5hbWU6IHN0cmluZztcbiAgICAgIG1vZGVsVHlwZTogc3RyaW5nO1xuICAgICAgbW9kZWxQYXRoT3JOYW1lOiBzdHJpbmc7XG4gICAgICBkZXNjcmlwdGlvbjogc3RyaW5nO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCBwYXJzZWRNb2RlbHM6IFJlY29yZDxzdHJpbmcsIHN0cmluZ1tdPiA9IHsgbW9kZWxzOiBbXSB9O1xuICAgIFxuICAgIChKU09OLnBhcnNlKG1vZGVsc0pTT04pIGFzIE1vZGVsRW50cnlbXSkuZm9yRWFjaCgob2JqKSA9PiB7XG4gICAgICBwYXJzZWRNb2RlbHMubW9kZWxzLnB1c2gob2JqLm1vZGVsTmFtZSk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBkZWZhdWx0TGFtYmRhID0gbmV3IGxhbWJkYS5GdW5jdGlvbih0aGlzLCBcIkRlZmF1bHRMYW1iZGFcIiwge1xuICAgICAgcnVudGltZTogbGFtYmRhLlJ1bnRpbWUuTk9ERUpTXzIwX1gsXG4gICAgICBoYW5kbGVyOiBcImluZGV4LmhhbmRsZXJcIixcbiAgICAgIGNvZGU6IGxhbWJkYS5Db2RlLmZyb21JbmxpbmUoXG4gICAgICAgIGBleHBvcnRzLmhhbmRsZXIgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0YXR1c0NvZGU6IDIwMCxcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgICAgICAgYm9keTogJyR7SlNPTi5zdHJpbmdpZnkocGFyc2VkTW9kZWxzKX0nXG4gICAgICAgICAgfTtcbiAgICAgICAgfTtgLFxuICAgICAgKSxcbiAgICB9KTtcbiAgICBhcGkucm9vdC5hZGRNZXRob2QoXCJHRVRcIiwgbmV3IGFwaWdhdGV3YXkuTGFtYmRhSW50ZWdyYXRpb24oZGVmYXVsdExhbWJkYSkpO1xuXG4gICAgY29uc3QgbW9kZWxzQ29uZmlnUGF0aCA9IHBhdGguam9pbihmaW5pc2hlZERpclBhdGgsIFwibW9kZWxzLmpzb25cIik7XG4gICAgbGV0IG1vZGVsczogTW9kZWxDb25maWdbXSA9IFtdO1xuXG4gICAgaWYgKGZzLmV4aXN0c1N5bmMobW9kZWxzQ29uZmlnUGF0aCkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG1vZGVscyA9IEpTT04ucGFyc2UoZnMucmVhZEZpbGVTeW5jKG1vZGVsc0NvbmZpZ1BhdGgsIFwidXRmOFwiKSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIGBFcnJvciByZWFkaW5nIG9yIHBhcnNpbmcgbW9kZWxzLmpzb24gZnJvbSAke21vZGVsc0NvbmZpZ1BhdGh9OmAsXG4gICAgICAgICAgZXJyb3IsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbW9kZWxzLmZvckVhY2goKG1vZGVsKSA9PiB7XG4gICAgICBjb25zdCBtb2RlbERpclBhdGggPSBwYXRoLmpvaW4oZmluaXNoZWREaXJQYXRoLCBtb2RlbC5tb2RlbE5hbWUpO1xuXG4gICAgICBpZiAoIWZzLmV4aXN0c1N5bmMobW9kZWxEaXJQYXRoKSkge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgYFdhcm5pbmc6IE1vZGVsIGRpcmVjdG9yeSBkb2VzIG5vdCBleGlzdCwgc2tpcHBpbmcgZGVwbG95bWVudCBmb3IgJHttb2RlbC5tb2RlbE5hbWV9OiAke21vZGVsRGlyUGF0aH1gLFxuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG1vZGVsTGFtYmRhID0gbmV3IGxhbWJkYS5Eb2NrZXJJbWFnZUZ1bmN0aW9uKFxuICAgICAgICB0aGlzLFxuICAgICAgICBgTGFtYmRhXyR7bW9kZWwubW9kZWxOYW1lfWAsXG4gICAgICAgIHtcbiAgICAgICAgICBjb2RlOiBsYW1iZGEuRG9ja2VySW1hZ2VDb2RlLmZyb21JbWFnZUFzc2V0KG1vZGVsRGlyUGF0aCwge1xuICAgICAgICAgICAgcGxhdGZvcm06IFBsYXRmb3JtLkxJTlVYX0FNRDY0LFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIG1lbW9yeVNpemU6IDMwMDgsXG4gICAgICAgICAgdGltZW91dDogY2RrLkR1cmF0aW9uLnNlY29uZHMoNjApLFxuICAgICAgICB9LFxuICAgICAgKTtcblxuICAgICAgY29uc3QgbW9kZWxSZXNvdXJjZSA9IGFwaS5yb290LmFkZFJlc291cmNlKG1vZGVsLm1vZGVsTmFtZSk7XG4gICAgICBjb25zdCBwcmVkaWN0UmVzb3VyY2UgPSBtb2RlbFJlc291cmNlLmFkZFJlc291cmNlKFwicHJlZGljdFwiKTtcbiAgICAgIHByZWRpY3RSZXNvdXJjZS5hZGRDb3JzUHJlZmxpZ2h0KHtcbiAgICAgICAgYWxsb3dPcmlnaW5zOiBhcGlnYXRld2F5LkNvcnMuQUxMX09SSUdJTlMsXG4gICAgICAgIGFsbG93TWV0aG9kczogW1wiUE9TVFwiLCBcIk9QVElPTlNcIl0sXG4gICAgICAgIGFsbG93SGVhZGVyczogW1wiQ29udGVudC1UeXBlXCJdLFxuICAgICAgfSk7XG4gICAgICBwcmVkaWN0UmVzb3VyY2UuYWRkTWV0aG9kKFxuICAgICAgICBcIlBPU1RcIixcbiAgICAgICAgbmV3IGFwaWdhdGV3YXkuTGFtYmRhSW50ZWdyYXRpb24obW9kZWxMYW1iZGEpLFxuICAgICAgKTtcblxuICAgICAgbmV3IGNkay5DZm5PdXRwdXQodGhpcywgYE1vZGVsRW5kcG9pbnRfJHttb2RlbC5tb2RlbE5hbWV9YCwge1xuICAgICAgICB2YWx1ZTogYCR7YXBpLnVybH0ke21vZGVsLm1vZGVsTmFtZX0vcHJlZGljdGAsXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIG5ldyBjZGsuQ2ZuT3V0cHV0KHRoaXMsIFwiUmVzdEFwaVVybFwiLCB7XG4gICAgICB2YWx1ZTogYXBpLnVybCxcbiAgICB9KTtcbiAgfVxufVxuIl19